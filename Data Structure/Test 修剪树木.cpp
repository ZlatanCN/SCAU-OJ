/*描述
学校的环境优美，景色宜人，种植了很多绿化树。最近天气预报显示台风即将到来，为应对台风天气，学校近日组织开展专项绿化修剪工作，排查绿化树木存在的安全隐患，
修剪过长或枯萎树枝。现在已知总共需要修剪的树木数量n（树木的序号为1...n，按相邻的次序排列）以及每棵树修剪的耗费时间，学校打算安排m位工作人员来修剪树木，
为了提高工作效率避免来回跑动，每位工作人员安排修剪的树木一定是相邻的。为了保证能在台风到来前完成工作，负责人需要知道安排m位工作人员去修剪树木，最快需要多少时间就能完成修剪。

输入格式
Line 1: 两个用空格分开的整数n和m，分别表示需要修剪的树木总数和派出的工作人员数目,1≤m≤n≤100,000
Lines 2..n+1: 第 i+1 行包含1个整数，表示修剪第i棵树需要的时间耗费ti(1 ≤ ti ≤ 10,000)，这n棵树按照相邻的次序排列

输出格式
Line 1: 输出最快能完成修剪所有树木的时间

输入样例
7 5
100
400
300
100
500
101
400

输出样例
500

提示
派出5个工作人员，第1个工作人员修剪第1、2两棵树（耗费时间为500），第2个工作人员修剪第3、4两棵树（耗费时间为400），第3个工作人员修剪第5棵树（耗费时间为500），
第4个工作人员修剪第6棵树（耗费时间为101），第5个工作人员修剪第7棵树（耗费时间为400），由于工作人员是同时工作的，所以最终总耗费时间500则可完成修剪任务.*/
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int N=1e5+10;
int n,m;
int a[N];
bool check(int mid)
{
    int j=1;
    for(int i=1;i<=m;i++)
    {
        int t=mid;
        while(t>=a[j])
        {
            t-=a[j];
            j++;
        }
        if(j>n+1)
        {
            return true;
        }
    }
    return false;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    int l=1,r=1e9;
    while(l<r)
    {
        int mid = (l + r) / 2;
        if(check(mid)) r=mid;
        else l=mid+1;
    }
    cout<<l;
    return 0;
}
